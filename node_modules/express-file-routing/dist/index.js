Object.defineProperty(exports, '__esModule', { value: true });

var express = require('express');
var path = require('path');
var fs = require('fs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);

const config = {
    VALID_FILE_EXTENSIONS: [".ts", ".js", ".mjs"],
    IGNORE_PREFIX_CHAR: "_",
    DEFAULT_METHOD_EXPORTS: [
        "get",
        "post",
        "put",
        "patch",
        "delete",
        "head",
        "connect",
        "options",
        "trace"
    ]
};

/**
 * @param parsedFile
 *
 * @returns Boolean Whether or not the file has to be excluded from route generation
 */
const isFileIgnored = (parsedFile) => !config.VALID_FILE_EXTENSIONS.includes(parsedFile.ext.toLowerCase()) ||
    parsedFile.name.startsWith(config.IGNORE_PREFIX_CHAR) ||
    parsedFile.dir.startsWith(`/${config.IGNORE_PREFIX_CHAR}`);
/**
 * @param routes
 *
 * @returns An array of sorted routes based on their priority
 */
const prioritizeRoutes = (routes) => routes.sort((a, b) => a.priority - b.priority);
/**
 * ```ts
 * mergePaths("/posts/[id]", "index.ts") -> "/posts/[id]/index.ts"
 * ```
 *
 * @param paths An array of mergeable paths
 *
 * @returns A unification of all paths provided
 */
const mergePaths = (...paths) => `/${paths.filter(path => path !== "").join("/")}`;
const regBackets = /\[([^}]*)\]/g;
const transformBrackets = (value) => regBackets.test(value) ? value.replace(regBackets, (_, s) => `:${s}`) : value;
/**
 * @param path
 *
 * @returns A new path with all wrapping `[]` replaced by prefixed `:`
 */
const convertParamSyntax = (path) => {
    const subpaths = [];
    for (const subpath of path.split("/")) {
        subpaths.push(transformBrackets(subpath));
    }
    return mergePaths(...subpaths);
};
/**
 * The smaller the number the higher the priority with zero indicating highest priority
 *
 * @param url
 *
 * @returns An integer ranging from 0 to Infinity
 */
const calculatePriority = (url) => {
    var _a, _b;
    const depth = ((_a = url.match(/\/.+?/g)) === null || _a === void 0 ? void 0 : _a.length) || 0;
    const specifity = ((_b = url.match(/\/:.+?/g)) === null || _b === void 0 ? void 0 : _b.length) || 0;
    return depth + specifity;
};
const getHandlers = handler => {
    if (!Array.isArray(handler))
        return [handler];
    return handler;
};
const getMethodKey = (method) => {
    let methodKey = method.toLowerCase();
    if (methodKey === "del")
        return "delete";
    return methodKey;
};

/**
 * @param directory The directory path to walk recursively
 * @param tree
 *
 * @returns An array of all nested files in the specified directory
 */
const walkTree = (directory, tree = []) => {
    const results = [];
    for (const fileName of fs.readdirSync(directory)) {
        const filePath = path__default["default"].join(directory, fileName);
        const fileStats = fs.statSync(filePath);
        if (fileStats.isDirectory()) {
            results.push(...walkTree(filePath, [...tree, fileName]));
        }
        else {
            results.push({
                name: fileName,
                path: directory,
                rel: mergePaths(...tree, fileName)
            });
        }
    }
    return results;
};
/**
 * @param files
 *
 * @returns
 */
const generateRoutes = (files) => {
    const routes = [];
    for (const file of files) {
        const parsedFile = path__default["default"].parse(file.rel);
        if (isFileIgnored(parsedFile))
            continue;
        const directory = parsedFile.dir === parsedFile.root ? "" : parsedFile.dir;
        const name = parsedFile.name.startsWith("index")
            ? parsedFile.name.replace("index", "")
            : `/${parsedFile.name}`;
        const url = convertParamSyntax(directory + name);
        const priority = calculatePriority(url);
        const exports = require(path__default["default"].join(file.path, file.name));
        routes.push({
            url,
            priority,
            exports
        });
    }
    return prioritizeRoutes(routes);
};

var _a;
const REQUIRE_MAIN_FILE = path__default["default"].dirname(((_a = require.main) === null || _a === void 0 ? void 0 : _a.filename) || process.cwd());
/**
 * Attach routes to an Express app or router instance
 *
 * ```ts
 * createRouter(app)
 * ```
 *
 * @param app An express app or router instance
 * @param options An options object (optional)
 */
const createRouter = (app, options = {}) => {
    var _a;
    const files = walkTree(options.directory || path__default["default"].join(REQUIRE_MAIN_FILE, "routes"));
    const routes = generateRoutes(files);
    for (const { url, exports } of routes) {
        const exportedMethods = Object.entries(exports);
        for (const [method, handler] of exportedMethods) {
            const methodKey = getMethodKey(method);
            const handlers = getHandlers(handler);
            if (!((_a = options.additionalMethods) === null || _a === void 0 ? void 0 : _a.includes(methodKey)) &&
                !config.DEFAULT_METHOD_EXPORTS.includes(methodKey))
                continue;
            app[methodKey](url, ...handlers);
        }
        // wildcard default export route matching
        if (typeof exports.default !== "undefined") {
            app.all(url, ...getHandlers(exports.default));
        }
    }
    return app;
};

/**
 * Routing middleware
 *
 * ```ts
 * app.use("/", router())
 * ```
 *
 * @param options An options object (optional)
 */
const router = (options = {}) => {
    return createRouter(express.Router(), options);
};

exports.createRouter = createRouter;
exports["default"] = createRouter;
exports.router = router;
//# sourceMappingURL=index.js.map
